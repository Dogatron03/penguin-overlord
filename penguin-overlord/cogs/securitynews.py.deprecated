# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at https://mozilla.org/MPL/2.0/.

"""
Security News Cog - Aggregates and posts security news from multiple sources.
"""

import logging
import discord
from discord.ext import commands, tasks
import aiohttp
import re
import json
import os
from datetime import datetime
from html import unescape

logger = logging.getLogger(__name__)


NEWS_SOURCES = {
    '404media': {
        'name': '404 Media',
        'url': 'https://404media.co/rss/',
        'color': 0xFF6B35,
        'icon': 'üì∞'
    },
    'arstechnica': {
        'name': 'Ars Technica Security',
        'url': 'https://feeds.arstechnica.com/arstechnica/security',
        'color': 0xFF4F00,
        'icon': 'üî¨'
    },
    'thehackernews': {
        'name': 'The Hacker News',
        'url': 'https://thehackernews.com/feeds/posts/default',
        'color': 0xD9231F,
        'icon': 'ÔøΩ'
    },
    'darkreading': {
        'name': 'Dark Reading',
        'url': 'https://www.darkreading.com/rss.xml',
        'color': 0x1A1A1A,
        'icon': 'üåë'
    },
    'bleepingcomputer': {
        'name': 'BleepingComputer',
        'url': 'https://www.bleepingcomputer.com/feed/',
        'color': 0x0066CC,
        'icon': 'üíª'
    },
    'eff': {
        'name': 'EFF Deeplinks',
        'url': 'https://www.eff.org/rss/updates.xml',
        'color': 0xC8102E,
        'icon': 'ÔøΩ'
    }
}


class SecurityNews(commands.Cog):
    """Security news aggregator and poster."""
    
    def __init__(self, bot):
        self.bot = bot
        self.session = None
        self.state_file = 'data/securitynews_state.json'
        self.state = self._load_state()
    
    def _load_state(self):
        """Load news poster state from file."""
        try:
            if os.path.exists(self.state_file):
                with open(self.state_file, 'r') as f:
                    return json.load(f)
        except Exception as e:
            logger.error(f"Error loading security news state: {e}")
        
        return {
            'last_posted': {},
            'channel_id': None,
            'enabled': False,
            'sources': list(NEWS_SOURCES.keys())  # All enabled by default
        }
    
    def _save_state(self):
        """Save news poster state to file."""
        try:
            os.makedirs(os.path.dirname(self.state_file), exist_ok=True)
            with open(self.state_file, 'w') as f:
                json.dump(self.state, f, indent=2)
        except Exception as e:
            logger.error(f"Error saving security news state: {e}")
    
    async def cog_load(self):
        """Create aiohttp session and start auto-poster when cog loads."""
        self.session = aiohttp.ClientSession()
        if self.state.get('enabled', False):
            self.news_auto_poster.start()
    
    async def cog_unload(self):
        """Close aiohttp session and stop auto-poster when cog unloads."""
        self.news_auto_poster.cancel()
        if self.session:
            await self.session.close()
    
    async def _fetch_rss_feed(self, source_key: str) -> list:
        """Fetch and parse RSS feed for a source."""
        source = NEWS_SOURCES[source_key]
        try:
            async with self.session.get(source['url'], timeout=15) as resp:
                if resp.status != 200:
                    logger.warning(f"Failed to fetch {source['name']}: HTTP {resp.status}")
                    return []
                
                content = await resp.text()
                
                # Extract items from RSS feed
                items = []
                item_pattern = r'<item>(.*?)</item>'
                matches = re.findall(item_pattern, content, re.DOTALL)
                
                for match in matches[:3]:  # Get latest 3 items
                    title_match = re.search(r'<title>(.*?)</title>', match, re.DOTALL)
                    link_match = re.search(r'<link>(.*?)</link>', match, re.DOTALL)
                    desc_match = re.search(r'<description>(.*?)</description>', match, re.DOTALL)
                    pubdate_match = re.search(r'<pubDate>(.*?)</pubDate>', match, re.DOTALL)
                    
                    if title_match and link_match:
                        title = unescape(re.sub(r'<[^>]+>', '', title_match.group(1).strip()))
                        link = link_match.group(1).strip()
                        
                        # Clean description
                        desc = ''
                        if desc_match:
                            desc_text = desc_match.group(1).strip()
                            # Remove CDATA
                            desc_text = re.sub(r'<!\[CDATA\[(.*?)\]\]>', r'\1', desc_text)
                            # Remove HTML tags
                            desc_text = re.sub(r'<[^>]+>', '', desc_text)
                            # Unescape HTML entities
                            desc_text = unescape(desc_text)
                            # Truncate
                            desc = desc_text[:200] + '...' if len(desc_text) > 200 else desc_text
                        
                        pubdate = pubdate_match.group(1).strip() if pubdate_match else None
                        
                        items.append({
                            'title': title,
                            'link': link,
                            'description': desc,
                            'pubdate': pubdate,
                            'source': source_key
                        })
                
                return items
        
        except Exception as e:
            logger.error(f"Error fetching {source['name']} RSS: {e}")
            return []
    
    @commands.hybrid_command(name='secnews', description='Get latest security news from multiple sources')
    async def secnews(self, ctx: commands.Context, source: str = None):
        """
        Get the latest security news from various sources.
        
        Usage:
            !secnews                    - Get news from all sources
            !secnews 404media          - Get news from 404 Media
            !secnews arstechnica       - Get news from Ars Technica
            !secnews thehackernews     - Get news from The Hacker News
            !secnews welivesecurity    - Get news from WeLiveSecurity
            !secnews darkreading       - Get news from Dark Reading
            !secnews awssecurity       - Get news from AWS Security Blog
            !secnews malwarebytes      - Get news from MalwareBytes
            !secnews wired             - Get news from Wired Security
        """
        await ctx.defer()
        
        sources_to_fetch = []
        if source:
            source = source.lower()
            if source in NEWS_SOURCES:
                sources_to_fetch = [source]
            else:
                await ctx.send(f"‚ùå Unknown source: `{source}`\nAvailable: {', '.join(NEWS_SOURCES.keys())}")
                return
        else:
            sources_to_fetch = list(NEWS_SOURCES.keys())
        
        all_items = []
        for src in sources_to_fetch:
            items = await self._fetch_rss_feed(src)
            all_items.extend(items)
        
        if not all_items:
            await ctx.send("‚ùå No news items found. Feeds may be temporarily unavailable.")
            return
        
        # Show latest 5 across all sources
        all_items = all_items[:5]
        
        for item in all_items:
            src_info = NEWS_SOURCES[item['source']]
            embed = discord.Embed(
                title=f"{src_info['icon']} {item['title']}",
                url=item['link'],
                description=item['description'] or "No description available",
                color=src_info['color'],
                timestamp=datetime.utcnow()
            )
            
            embed.set_footer(text=f"Source: {src_info['name']}")
            
            await ctx.send(embed=embed)
    
    @tasks.loop(hours=4)
    async def news_auto_poster(self):
        """Automatically post security news every 4 hours."""
        try:
            channel_id = self.state.get('channel_id')
            if not channel_id:
                return
            
            channel = self.bot.get_channel(channel_id)
            if not channel:
                logger.warning(f"Security news auto-poster: Channel {channel_id} not found")
                return
            
            enabled_sources = self.state.get('sources', list(NEWS_SOURCES.keys()))
            
            for source_key in enabled_sources:
                items = await self._fetch_rss_feed(source_key)
                
                # Post only the latest item if we haven't posted it before
                if items:
                    latest = items[0]
                    last_posted_link = self.state['last_posted'].get(source_key)
                    
                    if latest['link'] != last_posted_link:
                        src_info = NEWS_SOURCES[source_key]
                        embed = discord.Embed(
                            title=f"{src_info['icon']} {latest['title']}",
                            url=latest['link'],
                            description=latest['description'] or "No description available",
                            color=src_info['color'],
                            timestamp=datetime.utcnow()
                        )
                        
                        embed.set_footer(text=f"Source: {src_info['name']} ‚Ä¢ Auto-posted every 4 hours")
                        
                        await channel.send(embed=embed)
                        
                        self.state['last_posted'][source_key] = latest['link']
                        self._save_state()
                        logger.info(f"Security news auto-poster: Posted {source_key} to channel {channel_id}")
        
        except Exception as e:
            logger.error(f"Security news auto-poster error: {e}")
    
    @news_auto_poster.before_loop
    async def before_news_auto_poster(self):
        """Wait for the bot to be ready before starting the auto-poster."""
        await self.bot.wait_until_ready()
    
    @commands.hybrid_command(name='secnews_set_channel', description='Set the channel for automatic security news updates')
    @commands.has_permissions(manage_guild=True)
    async def secnews_set_channel(self, ctx: commands.Context, channel: discord.TextChannel = None):
        """
        Set the channel where security news will be posted every 4 hours.
        
        Usage:
            !secnews_set_channel #security-news
            /secnews_set_channel channel:#security-news
        
        Requires: Manage Server permission
        """
        channel = channel or ctx.channel
        self.state['channel_id'] = channel.id
        self._save_state()
        await ctx.send(f"‚úÖ Security news updates will be posted to {channel.mention} every 4 hours.\n"
                      f"Use `/secnews_enable` to start automatic posting.")
    
    @commands.hybrid_command(name='secnews_enable', description='Enable automatic security news updates')
    @commands.is_owner()
    async def secnews_enable(self, ctx: commands.Context):
        """
        Enable automatic security news updates every 4 hours.
        
        Usage:
            !secnews_enable
            /secnews_enable
        
        Requires: Bot owner only
        """
        if not self.state.get('channel_id'):
            await ctx.send("‚ùå Please set a channel first with `/secnews_set_channel`")
            return
        
        self.state['enabled'] = True
        self._save_state()
        
        if not self.news_auto_poster.is_running():
            self.news_auto_poster.start()
        
        channel = self.bot.get_channel(self.state['channel_id'])
        await ctx.send(f"‚úÖ Security news auto-posting **enabled** in {channel.mention if channel else 'the configured channel'}!\n"
                      f"Updates will be posted every 4 hours from {len(self.state.get('sources', NEWS_SOURCES))} sources.")
    
    @commands.hybrid_command(name='secnews_disable', description='Disable automatic security news updates')
    @commands.is_owner()
    async def secnews_disable(self, ctx: commands.Context):
        """
        Disable automatic security news updates.
        
        Usage:
            !secnews_disable
            /secnews_disable
        
        Requires: Bot owner only
        """
        self.state['enabled'] = False
        self._save_state()
        
        if self.news_auto_poster.is_running():
            self.news_auto_poster.cancel()
        
        await ctx.send("‚úÖ Security news auto-posting **disabled**.")
    
    @commands.hybrid_command(name='secnews_status', description='Check security news auto-poster status')
    async def secnews_status(self, ctx: commands.Context):
        """
        Check the status of the security news auto-poster.
        
        Usage:
            !secnews_status
            /secnews_status
        """
        channel_id = self.state.get('channel_id')
        channel = self.bot.get_channel(channel_id) if channel_id else None
        enabled = self.state.get('enabled', False)
        sources = self.state.get('sources', list(NEWS_SOURCES.keys()))
        
        embed = discord.Embed(
            title="üîí Security News Auto-Poster Status",
            color=0x1E88E5 if enabled else 0x757575
        )
        
        embed.add_field(
            name="Status",
            value="üü¢ Enabled" if enabled else "üî¥ Disabled",
            inline=True
        )
        
        embed.add_field(
            name="Channel",
            value=channel.mention if channel else "Not set",
            inline=True
        )
        
        embed.add_field(
            name="Frequency",
            value="Every 4 hours",
            inline=True
        )
        
        embed.add_field(
            name="Active Sources",
            value=f"{len(sources)}/{len(NEWS_SOURCES)}",
            inline=True
        )
        
        # List sources
        source_list = []
        for src in sources:
            info = NEWS_SOURCES[src]
            source_list.append(f"{info['icon']} {info['name']}")
        
        embed.add_field(
            name="Sources",
            value="\n".join(source_list) if source_list else "None",
            inline=False
        )
        
        embed.set_footer(text="Use /secnews_set_channel and /secnews_enable to configure")
        
        await ctx.send(embed=embed)


async def setup(bot):
    """Load the SecurityNews cog."""
    await bot.add_cog(SecurityNews(bot))
    logger.info("SecurityNews cog loaded")
